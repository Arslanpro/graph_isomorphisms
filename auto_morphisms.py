"""
This program implements the optimization in the branching algorithm, with the use of a generating set.
"""
from basicpermutationgroup import Orbit, Stabilizer
from graph import Graph, Vertex
from graph_io import load_graph
from permv2 import permutation

from color_refinement import color_refinement
from branching import is_balanced, is_bijection, get_c, count_isomorphism


def compute_order(h: list[permutation]) -> int:
    """
    Computes the order of h.
    Based on the theorem from slide 21.
    :param h: The permutation group on V.
    :return: The order of h.
    """

    # If only the trivial permutation is present in the generating set, the order is 1.
    if len(h) == 1 and h[0].istrivial():
        return 1

    # Choose a non-trivial orbit
    alpha = -1
    orbit = [0]
    while len(orbit) < 2:
        alpha += 1
        orbit = Orbit(h, alpha)

    # Calculate the order of the stabilizer
    stabilizer = Stabilizer(h, alpha)
    if len(stabilizer) == 0:
        stab_order = 1
    else:
        stab_order = compute_order(stabilizer)

    return len(orbit) * stab_order


def is_member(h: list[permutation], f: permutation) -> bool:
    """
    Test if f is in permutation group H.
    :param f: A permutation.
    :param h: A group of permutations.
    :return: True if f is already in H and False otherwise.
    """

    # Choose a non-trivial orbit
    alpha = -1
    orbit = []
    while len(orbit) < 2:
        alpha += 1

        # We can't find a non-trivial orbit, so f can't be generated by h
        if alpha >= f.n:
            return False
        orbit, u = Orbit(h, alpha, True)

    # Find the corresponding traversal element
    try:
        beta = orbit.index(f[alpha])
    except ValueError:
        return False
    u_beta = u[beta]

    # Make sure that the composition of f and u_beta is in the stabilizer of alpha
    composition = -u_beta * f
    stabilizer = Stabilizer(h, alpha)
    return composition in stabilizer or is_member(stabilizer, composition)


def count_automorphisms(g: Graph) -> int:
    """
    Counts the number of automorphisms that are present in the graph G.
    :param g: The graph G
    :return: The number of automorphisms.
    """

    def generate_mapping(g: Graph, h: Graph):
        """
        Generates the corresponding mapping from vertex to vertex for the isomorphism between graphs g and h.
        We map g to h.
        :param g: A graph
        :param h: A graph
        :return: A permutation with the mapping from g to h
        """
        mapping = [0] * len(g.vertices)
        for v_g in g:
            for v_h in h:
                if v_g.colornum == v_h.colornum:
                    mapping[v_g.label] = v_h.label
        return permutation(len(mapping), mapping=mapping)

    def generate_automorphisms(g: Graph, h: Graph, d: list[Vertex], i: list[Vertex]):
        """
        Is called recursively to traverse through the branching tree and to find all automorphisms.
        :param g: A copy of the original graph
        :param h: Another copy of the original graph
        :param d: A list with pre-colored vertices for graph g
        :param i: A list with pre-colored vertices for graph h
        """

        # Refine the graphs g and h.
        color_refinement([g, h])

        # Make sure that the colors are balanced, and check for a bijection.
        if not is_balanced(g, h):
            return
        if is_bijection(g, h):

            # Generate the mapping from g -> h.
            p = generate_mapping(g, h)

            # If the permutation cannot be generated by this generating set, we need to add it.
            if not is_member(generating_set, p):
                generating_set.append(p)

            # We can now back to the last trivial ancestor nodes in the branching tree.
            while [v.label for v in d] != [v.label for v in i]:
                # We remove the vertices from d and i and mark them as 'used'.
                # This should prevent the algorithm from trying to re-explore a branch that may be skipped.
                # FIXME: This strategy seems too aggressive, the results are sometimes off by a factor 2 or 4
                d.pop().pre_labeled = True
                i.pop().pre_labeled = True

            return

        c, next_color = get_c([g, h])
        for v_g in g:
            if v_g.colornum == c:# and not v_g.pre_labeled:
                x = v_g
                break

        for v_h in h:
            if v_h.colornum == c and not v_h.pre_labeled:
                g1 = g + Graph(False)
                h1 = h + Graph(False)
                g1.vertices[g.vertices.index(x)].colornum = next_color
                h1.vertices[h.vertices.index(v_h)].colornum = next_color
                d.append(x)
                i.append(v_h)
                generate_automorphisms(g1, h1, d, i)

    generating_set = []
    graph_copy_1 = g + Graph(False)
    graph_copy_2 = g + Graph(False)
    for v in graph_copy_1.vertices:
        v.pre_labeled = False
    for v in graph_copy_2.vertices:
        v.pre_labeled = False
    generate_automorphisms(graph_copy_1, graph_copy_2, [], [])
    return compute_order(generating_set)


if __name__ == '__main__':

    graph_name = input("Please enter the name of the graph file (leave empty for cubes3.grl): ")
    if graph_name == "":
        graph_name = "cubes3.grl"

    try:
        with open('graphs/branching/' + graph_name) as f:
            graphs = load_graph(f, read_list=True)
    except FileNotFoundError:
        print(f"Unable to open {graph_name}, make sure that it is located in graphs/branching!")
        exit()

    for i in range(len(graphs[0])):
        g = graphs[0][i]
        c_auto = count_automorphisms(g + Graph(False))
        print(f"Graph {i} count_automorphisms: {c_auto}; ", end="")

        c_iso = count_isomorphism(g + Graph(False), g + Graph(False), [], [])
        print(f"count_isomorphisms: {c_iso}")